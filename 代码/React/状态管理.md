使用 Redux 管理数据，MobX 也是一个状态管理工具
React 内置 Context 和 useReduce
### 什么是状态管理
状态提升
页面拆分组件，组件嵌套
数据存储在父组件
通过 props 传递给子组件、
状态管理
如果页面很复杂：组件很多，嵌套层级很深
通过 props 层层传递不合适
需要状态管理，即集中统一管理页面数据

Context
可以跨层级传递
类似 Vue 的 provide/inject
切换主题，切换语言等

useReduce
是 useState 的代替方案
数据简单的时候用 useState ,复杂时用 useReduce
简化版的 redux

store 或者 state 是数据
action 命令
reducer 规定，返回新的 state
dispatch 派发 action 用的

类似 redux 的流程和 API
结合 context 解决跨组件问题
state dispatch 默认没有模块化，数据混在一起

```tsx
import React, { FC, useReducer } from "react";

type StateType = { count: number };
type ActionType = { type: string };

const initialState: StateType = { count: 100 }; // 初始值

// 根据传入的 action 返回新的 state
function reducer(state: StateType, action: ActionType) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

const CountReducer: FC = () => {
  //   const [count, setCount] = useState(100);
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      <span>{state.count}</span>
      {/* <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button> */}
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </>
  );
};

export default CountReducer;
```