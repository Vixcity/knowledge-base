# 1. 函数式组件
创建函数式组件的名称最好大写，因为大写的字母，React 会以组件的方式去进行渲染，你的甘薯名就是你的组件名

函数式组件创建了之后，首先 React 会去解析组件标签，找到对应的组件

找到组件之后，发现组件是由函数定义的，随后便找到该函数，将返回的虚拟DOM转为真实DOM，呈现在页面中

``` javascript
 // 1. 创建函数式组件 首字母最好大写，这样可以 React 会以组件的方式去进行渲染
 function Demo() {
	 console.log(this) // 此处的 this 是 undefined，因为babel编译后开启了严格模式
	 return <h2> 我是用函数定义的组件（适用于简单组件的定义）</h2>
 }

 // 2. 渲染组件到页面
 ReactDOM.render(<Demo/>,document.getElementById('test'))
 // 以下方法也可以进行渲染
 // ReactDOM.render(demo(),document.getElementById('test'))

 // 执行了 ReactDOM.render(<Demo/>,document.getElementById('test'))之后，发生了什么？
 //      1. React解析组件标签，找到了Demo组件
 //      2. 发现组件是用函数定义的，随后找到该函数，将返回的虚拟DOM转为真实DOM，呈现在页面中
```

# 2. 类式组件
如果你的组件有状态，那么就是复杂组件，复杂组件用类式组件

创建类式组件的时候需要继承一个 React 的内置类

创建的类需要有一个 render 方法，放在类的原型对象组件里面，以下文为例，放在 Demo 组件对象里面

render 里面的 this，是指向的组件实例对象，React 在render里面发现你是类式组件，就会帮你 new 一个实例对象出来

```javascript
// 创建类式组件
 class Demo extends React.Component {
	 render() {
		 // render 是放在哪里的
		 // 类的原型对象，供实例使用
		 // render中的this是组件实例对象
		 console.log('render中的this',this)
		 return <h2> 我是用类定义的组件（适用于复杂组件的定义）</h2>
	 }
 }

 // 渲染组件到页面
 ReactDOM.render(<Demo/>,document.getElementById('test'))
 // 执行了 ReactDOM.render(<Demo/>,document.getElementById('test'))之后，发生了什么？
 //      1. React解析组件标签，找到了Demo组件
 //      2. 发现组件是用类定义的，随后new出来该类的实例，并通过该实例，调用到原型上的render方法
 //      3. 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中
```

## 2.1 三大属性之一 - state
只能用需要用 setState 去修改赋值，且更新是一种合并，不是替换

组件里面的自定义方法当中只要有用到 this 的就会有 this 的指向问题

因为没有通过实例调用，而是执行的时候直接去调用

构造器只调用1次，组件实例对象里面的render函数调用了1+n次（n是状态更新的次数）

自定义方法，执行几次调用几次

点击事件需要这样写 onClick = { this.changeWeather } 这样会有 this 指向问题

 因为这样相当于直接把下面的 changeWeather 方法给 onClick 做回调
 
  所以此时的 changeWeather 的 this 指向的是 undefined
  
 这个时候需要用 this.changeWeather = this.changeWeather.bind(this) 
 
 把 changeWeather 里面的 this 重新绑定到这个 render 里面的 this （此时 this 指向实例对象）
				 
 把原来歪了的 this 拉回来
 
 【严重注意！！】
 - 组件的状态不可直接更改，要借助一个内置的API进行更改
 
 以下写法为错误写法

>this.state.isHot = !isHot // 此时这里进行了直接修改，这样是不能更新页面上的状态的
// 如果想要修改状态，必须要用setState去修改,且更新是一种合并，不是替换

```html
<!-- 
 <script type="text/babel">
	 class Weather extends React.Component {
		 constructor (props) {
			 super(props)
			 this.state = {isHot:true}
		 }
		 render() {
			 const { isHot } = this.state
			 return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}</h1>


			 【严重注意！！！】
				 这个里面的this.changeWeather
				 相当于直接把下面的changeWeather方法给onClick做回调
				 但是他没有通过实例调用，而是点击的时候直接去调用
				 再加上在calss里面会自动默认帮你生成一个严格模式
				 所以此时的changeWeather的this指向的是undefined
				 这个时候需要用this.changeWeather = this.changeWeather.bind(this) 把changeWeather里面的this重新绑定到这个render里面的this
				 把原来歪了的this拉回来
			 【严重注意！！！】

		 }

		 changeWeather() {
			 const { isHot } = this.state
			 this.state.isHot = !isHot
		 } 
	 }
	 ReactDOM.render(<Weather/>,document.getElementById('test'))
 </script> 
-->


<script type="text/babel">
	 // 1. 创建组件
	 class Weather extends React.Component {
		 // 构造器调用几次？ -- 1次（初始化的时候）
		 constructor (props) {
			 super(props)
			 // 初始化状态
			 this.state = {isHot:true}
			 // 解决 changeWeather 中 this 指向问题
			 this.changeWeather = this.changeWeather.bind(this)
		 }

		 // render 调用几次？ -- 1+n次 1是初始化那次，n是状态更新的次数
		 render() {
			 // 对于状态进行展示
			 // 通过解构赋值进行放置数据
			 const { isHot } = this.state
			 // onClick 添加点击事件
			 // 原生的3种添加事件都支持,更推荐在标签上直接写onClick
			 // onClick 不支持添加引号,需要直接写表达式的函数,不能添加括号,添加括号就相当于被执行了获取到的返回值为默认函数的返回值 undefined
			 return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}</h1>
		 }

		 // changeWeather调用几次？ -- 点几次调几次
		 changeWeather() {
			 // changeWeather 放在了Weather 的原型上
			 // 获取原来的isHot值
			 const { isHot } = this.state
			 // 【严重注意！！】状态不可直接更改，要借助一个内置的API进行更改,以下写法为错误写法
			 // this.state.isHot = !isHot
			 // 如果想要修改状态，需要用setState去修改,且更新是一种合并，不是替换
			 this.setState({isHot:!isHot})
		 } 
	 }

	 // 2. 渲染组件到页面
	 ReactDOM.render(<Weather/>,document.getElementById('test'))
</script>
```
state 必须为对象

组件是通过更新 state 的值来更新对应的页面操作（重新渲染组件）

组件中 render 方法里面的 this 为组件实例对象

组件自定义方法中 this 指向 undefined，如何解决？
- 强制绑定 this 通过函数对象 bind
- 箭头函数